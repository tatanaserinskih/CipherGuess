<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CipherGuess — Private Guessing (Zama FHEVM)</title>
  <link rel="preconnect" href="https://cdn.zama.ai"/>
  <link rel="preconnect" href="https://cdn.jsdelivr.net"/>
  <style>
    :root{
      --bg:#0c0f14;--card:#141923;--muted:#8ea3b0;--text:#e9f0f4;--accent:#60a5fa;--accent2:#22d3ee;--ok:#10b981;
      --btn:#1f2937;--btn2:#243242;--br:14px;--bd:1px solid #253043;--shadow:0 8px 30px rgba(0,0,0,.28);
    }
    *{box-sizing:border-box} body{margin:0;font:16px/1.45 Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--text)}
    .wrap{max-width:980px;margin:26px auto;padding:0 14px}
    header.hero{display:flex;align-items:center;gap:14px;margin-bottom:18px;flex-wrap:wrap}
    .logo{margin:0;font-weight:800;letter-spacing:.2px}
    .logo span{color:var(--accent2)}
    .badge{background:#1b2331;border:var(--bd);color:#cfe4f5;border-radius:999px;padding:6px 10px;font-size:12px}
    .btn{background:var(--btn);border:var(--bd);color:#d8e7f3;padding:10px 14px;border-radius:999px;cursor:pointer}
    .btn[disabled]{opacity:.6;cursor:not-allowed}
    .btn.primary{background:#2b3a52}
    .btn.accent{background:#1f2d46;color:#e8f2ff;border-color:#35507c}
    .panel{margin:12px 0}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:14px}
    .card{background:var(--card);border:var(--bd);border-radius:var(--br);padding:16px;box-shadow:var(--shadow)}
    h2{margin:0 0 10px 0;font-size:16px;color:#d6e8f7}
    input[type="number"], input[type="text"]{
      width:180px;background:#0e1521;border:var(--bd);border-radius:10px;padding:10px 12px;color:#dbeaf6;outline:none
    }
    .status{margin-top:8px;color:var(--muted);font-size:13px}
    .resultBox{min-height:48px;display:flex;align-items:center;border:1px dashed #2b3955;border-radius:12px;padding:12px}
    .muted{color:var(--muted)}
    .foot{margin:20px 0;color:#86a0b0;text-align:center;font-size:12px}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .kv{display:flex;gap:10px;align-items:center}
    strong{font-weight:700}
    .chip{display:inline-block;background:#1a2431;border:1px solid #2a3a55;border-radius:999px;padding:6px 10px;font-size:12px;color:#bcd1e2}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.2/dist/ethers.umd.min.js"></script>
</head>
<body>
  <main class="wrap">
    <header class="hero">
      <h1 class="logo">Cipher<span>Guess</span></h1>
      <span id="netBadge" class="badge">Network: —</span>
      <span id="ctrBadge" class="badge">Contract: —</span>
      <button id="connectBtn" class="btn primary" style="margin-left:auto">Connect Wallet</button>
    </header>

    <section class="panel grid">
      <div class="card">
        <h2>Range</h2>
        <div class="kv"><span>Secret is in</span> <strong id="rangeOut">0 … —</strong></div>
      </div>

      <div class="card">
        <h2>Your Guess</h2>
        <div class="row">
          <input id="guessInput" type="number" min="0" value="0" />
          <button id="playBtn" class="btn accent">Play</button>
        </div>
        <div id="status" class="status muted"></div>
        <div id="txOut" class="status muted"></div>
      </div>
    </section>

    <section class="panel">
      <div class="card result">
        <h2>Result</h2>
        <div id="resultBox" class="resultBox muted">Make a guess to see if you win.</div>
      </div>
    </section>

    <section class="panel">
      <div class="card">
        <h2>Owner tools</h2>
        <div class="row">
          <label class="row" style="gap:8px">
            <span>Seed (≤ N):</span>
            <input id="seedInput" type="number" min="0" placeholder="e.g. 5" />
          </label>
          <button id="reseedBtn" class="btn">Reseed (encrypted)</button>
        </div>
        <small class="muted">Only contract owner can reseed.</small>
      </div>
    </section>

    <footer class="foot">Built with Zama FHEVM • Demo only</footer>
  </main>

  <script>
    window.CONFIG = {
      NETWORK_NAME: "Sepolia",
      CHAIN_ID_HEX: "0xaa36a7",
      CONTRACT_ADDRESS: "0xb7962E717F58b075F9D5229Bf0F8287b58804955"
    };
  </script>

  <script>
    window.CG_ABI = [
      { "type":"function","name":"N","stateMutability":"view","inputs":[],"outputs":[{"type":"uint16"}]},
      { "type":"function","name":"play","stateMutability":"nonpayable","inputs":[{"type":"bytes32"},{"type":"bytes"}],"outputs":[{"type":"bytes32"}]},
      { "type":"function","name":"reseed","stateMutability":"nonpayable","inputs":[{"type":"bytes32"},{"type":"bytes"}],"outputs":[]},
      { "type":"event","name":"Played","inputs":[
          {"name":"player","type":"address","indexed":true},
          {"name":"resultHandle","type":"bytes32","indexed":false}
        ],"anonymous":false}
    ];
  </script>

  <!-- RELAYER + дешифровка -->
  <script>
  (() => {
    const SDK_URL = "https://cdn.zama.ai/relayer-sdk-js/0.2.0/relayer-sdk-js.js";
    let _sdk = null, _relayer = null, _sepCfg = null;

    const hexToBytes = (hex) => {
      if (!hex) return new Uint8Array();
      let h = String(hex);
      if (h.startsWith("0x") || h.startsWith("0X")) h = h.slice(2);
      if (h.length % 2) h = "0" + h;
      const out = new Uint8Array(h.length / 2);
      for (let i = 0; i < out.length; i++) out[i] = parseInt(h.substr(i*2, 2), 16);
      return out;
    };

    // Нормальное извлечение булевого из любого формата ответа SDK
    function extractBool(resp, handleHex) {
      console.log("[Decrypt] raw response", resp);
      const h = String(handleHex);
      const keys = [
        h, h.toLowerCase(), h.toUpperCase()
      ];
      // 1) массивы значений
      const arr = resp?.values ?? resp?.results ?? resp?.data ?? (Array.isArray(resp) ? resp : null);
      if (Array.isArray(arr) && arr.length) return normalizeBool(arr[0]);
      // 2) одиночное поле value
      if (typeof resp?.value !== "undefined") return normalizeBool(resp.value);
      // 3) объект-мапа { handleHex: bool }
      if (resp && typeof resp === "object") {
        for (const k of keys) {
          if (Object.prototype.hasOwnProperty.call(resp, k)) return normalizeBool(resp[k]);
        }
        // если ключей нет/не совпали — взять первое значение объекта
        const firstKey = Object.keys(resp)[0];
        if (typeof firstKey !== "undefined") return normalizeBool(resp[firstKey]);
      }
      // 4) дефолт — приводим как примитив
      return normalizeBool(resp);
    }

    function normalizeBool(val){
      if (typeof val === "boolean") return val;
      if (typeof val === "number") return val !== 0;
      if (typeof val === "string") return val === "true" || val === "1";
      return !!val;
    }

    async function _loadSDK(){
      if (_sdk) return _sdk;
      _sdk = await import(SDK_URL);
      _sepCfg = _sdk?.SepoliaConfig || null;
      console.log("[RelayerSDK] loaded", _sdk);
      return _sdk;
    }
    async function initRelayer(){
      if (_relayer) return _relayer;
      const { initSDK, createInstance, SepoliaConfig } = await _loadSDK();
      await initSDK();
      const cfg = {
        ...(SepoliaConfig || {}),
        network: window.ethereum,
        relayerUrl: "https://relayer.testnet.zama.cloud",
        gatewayUrl: "https://gateway.sepolia.zama.ai/",
        debug: true,
      };
      console.log("[RelayerSDK] createInstance cfg", cfg);
      _relayer = await createInstance(cfg);
      console.log("[RelayerSDK] instance ready", _relayer);
      return _relayer;
    }

    function _attachExtra(enc, ca, ua){
      const extra = {
        contractAddress: ca,
        userAddress: ua,
        chainId: (_sepCfg?.chainId) || "0xaa36a7",
        kmsContractAddress: _sepCfg?.kmsContractAddress,
        aclContractAddress: _sepCfg?.aclContractAddress,
      };
      if (typeof enc.setExtraData === "function") enc.setExtraData(extra);
      else enc.extraData = extra;
    }

    async function encrypt16For(contractAddress, userAddress, valueBigInt){
      const r = await initRelayer();
      let lastErr;
      try{
        const encO = r.createEncryptedInput({ contractAddress, userAddress });
        _attachExtra(encO, contractAddress, userAddress);
        encO.add16(BigInt(valueBigInt));
        console.log("[Encrypt] encO before encrypt", encO);
        const out = await encO.encrypt();
        console.log("[Encrypt] encO result", out);
        const handle = (out?.handles || out?.externalValues)?.[0];
        const proof  =  out?.inputProof || out?.attestation;
        if (!handle || !proof) throw new Error("Encrypt: missing handle/proof");
        return { handle, attestation: proof };
      }catch(e1){ console.warn("[Encrypt] pathA failed", e1); lastErr = e1; }
      try{
        const encP = r.createEncryptedInput(contractAddress, userAddress);
        _attachExtra(encP, contractAddress, userAddress);
        encP.add16(BigInt(valueBigInt));
        console.log("[Encrypt] encP before encrypt", encP);
        const out = await encP.encrypt();
        console.log("[Encrypt] encP result", out);
        const handle = (out?.handles || out?.externalValues)?.[0];
        const proof  =  out?.inputProof || out?.attestation;
        if (!handle || !proof) throw new Error("Encrypt: missing handle/proof");
        return { handle, attestation: proof };
      }catch(e2){ console.warn("[Encrypt] pathB failed", e2); lastErr = e2; }
      throw new Error("encrypt16For failed: " + (lastErr?.message || String(lastErr)));
    }

    async function tryUserDecrypt(handleHex, contractAddress, userAddress){
      const r = await initRelayer();
      const bytes = hexToBytes(handleHex);
      const variants = [
        () => r.userDecrypt({ handles: [bytes], contractAddress, userAddress, types: ["bool"] }),
        () => r.userDecrypt({ handles: [handleHex], contractAddress, userAddress, types: ["bool"] }),
        () => r.userDecrypt({ handle:  bytes,   contractAddress, userAddress, types: ["bool"] }),
        () => r.userDecrypt({ handle:  handleHex, contractAddress, userAddress, types: ["bool"] }),
        () => r.userDecrypt([bytes], contractAddress, userAddress),
        () => r.userDecrypt([handleHex], contractAddress, userAddress),
        () => r.userDecrypt(bytes,   contractAddress, userAddress),
        () => r.userDecrypt(handleHex,contractAddress, userAddress),
      ];
      let lastErr;
      for (const [i,call] of variants.entries()){
        try{
          console.log(`[Decrypt:user] try v${i+1}`);
          const resp = await call();
          const bool = extractBool(resp, handleHex);
          console.log(`[Decrypt:user] v${i+1} parsed`, bool);
          return bool;
        }catch(e){ console.warn(`[Decrypt:user] v${i+1} failed`, e); lastErr = e; }
      }
      throw lastErr || new Error("userDecrypt: all variants failed");
    }

    async function tryPublicDecrypt(handleHex){
      const r = await initRelayer();
      const bytes = hexToBytes(handleHex);
      const variants = [
        () => r.publicDecrypt({ handles: [bytes], types: ["bool"] }),
        () => r.publicDecrypt({ handles: [handleHex], types: ["bool"] }),
        () => r.publicDecrypt({ handle:  bytes, types: ["bool"] }),
        () => r.publicDecrypt({ handle:  handleHex, types: ["bool"] }),
        () => r.publicDecrypt([bytes]),
        () => r.publicDecrypt([handleHex]),
        () => r.publicDecrypt(bytes),
        () => r.publicDecrypt(handleHex),
      ];
      let lastErr;
      for (const [i,call] of variants.entries()){
        try{
          console.log(`[Decrypt:public] try v${i+1}`);
          const resp = await call();
          console.log(`[Decrypt:public] v${i+1} response`, resp);
          const bool = extractBool(resp, handleHex);
          console.log(`[Decrypt:public] v${i+1} parsed`, bool);
          return bool;
        }catch(e){ console.warn(`[Decrypt:public] v${i+1} failed`, e); lastErr = e; }
      }
      throw lastErr || new Error("publicDecrypt: all variants failed");
    }

    // экспортируем в window
    window.initRelayer = initRelayer;
    window.encrypt16For = encrypt16For;
    window.tryUserDecrypt = tryUserDecrypt;
    window.tryPublicDecrypt = tryPublicDecrypt;
  })();
  </script>

  <!-- APP -->
  <script>
  (function(){
    const $ = (sel, root=document) => root.querySelector(sel);
    const short = (a) => a ? (String(a).slice(0,6)+"…"+String(a).slice(-4)) : "—";
    const setText = (sel, t) => { const el=$(sel); if(el) el.textContent=t; };

    const CONTRACT = CONFIG.CONTRACT_ADDRESS;
    let provider=null, signer=null, address="", contract=null, N=0n;

    const btnConnect = $("#connectBtn");
    const rangeOut = $("#rangeOut");
    const inpGuess = $("#guessInput");
    const btnPlay  = $("#playBtn");
    const statusEl = $("#status");
    const txOut    = $("#txOut");
    const resultBox= $("#resultBox");
    const inpSeed  = $("#seedInput");
    const btnReseed= $("#reseedBtn");

    function status(msg){ if(statusEl){ statusEl.textContent = msg || ""; } console.log("[UI] status:", msg); }
    function txmsg(msg){ if(txOut){ txOut.textContent = msg || ""; } console.log("[TX]", msg); }

    async function ensureProvider(){
      if (!window.ethereum) throw new Error("Install MetaMask");
      if (!provider) provider = new window.ethers.BrowserProvider(window.ethereum);
      return provider;
    }

    async function connect(){
      const p = await ensureProvider();
      const net = await p.getNetwork();
      console.log("[Net] current", net);
      const want = BigInt(CONFIG.CHAIN_ID_HEX);
      if (net.chainId !== want){
        console.log("[Net] switching to", CONFIG.CHAIN_ID_HEX);
        await window.ethereum.request({ method: "wallet_switchEthereumChain", params: [{ chainId: CONFIG.CHAIN_ID_HEX }] });
      }
      await p.send("eth_requestAccounts", []);
      signer = await p.getSigner();
      address = await signer.getAddress();
      console.log("[Wallet] address", address);
      btnConnect.textContent = short(address);
      await onConnected();
    }

    async function onConnected(){
      const p = await ensureProvider();
      contract = new window.ethers.Contract(CONTRACT, window.CG_ABI, signer || p);
      console.log("[Contract] bound", CONTRACT, contract);

      try{
        const nVal = await contract.N();
        N = BigInt(nVal);
        rangeOut.textContent = `0 … ${N.toString()}`;
      }catch(e){ console.warn("[Contract] read N failed", e); rangeOut.textContent = "0 … —"; }

      try { await window.initRelayer(); } catch(e){ console.warn("[Relayer] preload failed", e); }

      btnPlay.disabled = false;
      status("Wallet connected");
    }

    setText("#netBadge", "Network: " + (CONFIG.NETWORK_NAME || "—"));
    setText("#ctrBadge", "Contract: " + short(CONTRACT));
    btnPlay.disabled = true;

    $("#connectBtn")?.addEventListener("click", () => connect().catch(e=>status(e.message||String(e))));

    btnPlay?.addEventListener("click", async () => {
      try{
        if (!contract) await connect();
        const vRaw = String(inpGuess.value||"0").trim();
        if (vRaw === "") { status("Enter a number"); return; }
        const v = BigInt(vRaw);
        if (v < 0n) { status("Value must be ≥ 0"); return; }
        if (N>0n && v>N) { status("Value must be in 0..N"); return; }

        const { handle, attestation } = await window.encrypt16For(CONTRACT, address, v);
        console.log("[Play] enc handle/proof", handle, attestation);

        const tx = await contract.play(handle, attestation);
        txmsg("TX sent: " + tx.hash);
        const receipt = await tx.wait();
        txmsg("Play done — block " + receipt.blockNumber);
        console.log("[Play] receipt", receipt);

        const iface = new ethers.Interface(window.CG_ABI);
        const topic = iface.getEvent("Played").topicHash;
        let resultHandle = null;
        for (const log of receipt.logs) {
          if (log.address?.toLowerCase() !== CONTRACT.toLowerCase()) continue;
          if (!log.topics || log.topics[0] !== topic) continue;
          try {
            const parsed = iface.parseLog(log);
            resultHandle = parsed?.args?.resultHandle;
            console.log("[Event] Played parsed", parsed);
            break;
          } catch (e) { console.warn("[Event] parse fail", e, log); }
        }
        console.log("[Event] resultHandle", resultHandle);
        if (!resultHandle) { resultBox.textContent = "Played, but result handle not found in logs."; return; }

        try{
          const isWinPrivate = await window.tryUserDecrypt(resultHandle, CONTRACT, address);
          console.log("[Decrypt] user result", isWinPrivate);
          resultBox.textContent = isWinPrivate ? "You WIN 🎉" : "Nope, try again.";
        }catch(e1){
          console.warn("[Decrypt] user failed, try public", e1);
          try{
            const isWinPublic = await window.tryPublicDecrypt(resultHandle);
            console.log("[Decrypt] public result", isWinPublic);
            resultBox.textContent = isWinPublic ? "You WIN 🎉" : "Nope, try again.";
          }catch(e2){
            console.error("[Decrypt] both failed", e2);
            resultBox.textContent = "Played. Decrypt failed: " + (e2?.message || e1?.message || e2 || e1);
          }
        }
      }catch(e){
        console.error("[Play] error", e);
        status("Play error: " + (e?.message||e));
      }
    });

    btnReseed?.addEventListener("click", async () => {
      try{
        if (!contract) await connect();
        const raw = String(inpSeed.value||"").trim();
        if (!raw){ status("Enter seed"); return; }
        const s = BigInt(raw);
        if (s < 0n) { status("Seed must be ≥ 0"); return; }
        if (N>0n && s>N){ status("Seed must be ≤ N"); return; }

        const { handle, attestation } = await window.encrypt16For(CONTRACT, address, s);
        console.log("[Reseed] enc handle/proof", handle, attestation);

        const tx = await contract.reseed(handle, attestation);
        txmsg("Reseed TX: " + tx.hash);
        await tx.wait();
        txmsg("Reseeded");
      }catch(e){
        console.error("[Reseed] error", e);
        status("Reseed error: " + (e?.message||e));
      }
    });

    (async () => {
      try{
        if (window.ethereum){
          const p = new window.ethers.BrowserProvider(window.ethereum);
          const accs = await p.send("eth_accounts", []);
          console.log("[Auto] accounts", accs);
          if (accs && accs[0]) {
            signer = await p.getSigner();
            address = await signer.getAddress();
            console.log("[Auto] address", address);
            $("#connectBtn").textContent = short(address);
            await onConnected();
          }
        }
      }catch(e){ console.warn("[Auto] failed", e); }
    })();
  })();
  </script>
</body>
</html>
